<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>这辈子跟技术耗上了 - Github.io by micyng</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>这辈子跟技术耗上了 - Github.io</h1>
        <p></p>


        <p class="view"><a href="https://github.com/micyng">View My GitHub Profile</a></p>

      </header>
      <section>
        <p>{{&gt;toc}}</p>

<p>h1. tls报文概述</p>

<ul>
<li>tls在tcp基础上构建，所以本质还是tcp；目的是在tcp基础上构建一个通信双方可信赖的安全通道，所以还是基于连接的会话</li>
<li>这个会话经历 <em>握手</em> 和 <em>app层数据</em> 2个阶段；握手完成后即可传输application的应用数据</li>
<li>整体结构由2部分组成：tls头部、具体协议；tls头部表明目前处于的状态（特指tls1.2及以上封装格式）</li>
<li>tls头部的结构固定由以下几字节组成，均以大端表示；在tls头部之后即紧跟着具体的协议字节</li>
</ul>

<p>|1|2|3|4|5|
|ContentType|\2=.TLS协议版本|\2=.协议payload长度|</p>

<ul>
<li>协议版本&amp;协议payload长度容易理解；ContentType表明tls协议栈当前所处的状态（tls时序规定必须先完成HandShake握手阶段，然后才能开始应用层传输数据，即ApplicationData状态，在这个过程中如果出现错误，都有可能出现Alert警告消息）
## HandShake
## Alert
## ApplicationData
## ChangeCipherSpec （tls1.3中已废除）</li>
</ul>

<p>h1. 时序</p>

<p>tls协议基于证书链这种可以被通信双方信任的机制进行
通信过程中以 <em>握手</em> 完成证书交换以及后续对称密钥的协商；握手之后即可通过对称密钥完成后续的业务数据交换</p>

<p>!tls12_cd.png!</p>

<p>h1. 封装算法</p>

<p>表示 <em>握手</em> 和其他时序中协议报文的封装格式和注意点</p>

<p>h2. ClientHello</p>

<p>h3. 整体格式</p>

<p>|1|2|3|4|more|
|协议类型|\3=.协议包长度（比较奇葩，tls头部仅用2字节表示长度，这里反而用3字节）|handshake握手数据段|</p>

<p>h3. handshake数据段</p>

<p>|说明|占用字节数|
|tls版本|2|
|client随机数|32|
|协议会话id|1（不支持会话重建，用0表示即可）|
|加密套件长度|套件count*2|
|每个加密套件id|2|
|是否支持压缩|1|
|压缩算法|1（不支持压缩，置0即可）|
|扩展长度|2（二进制表示，最长支持0xffff种扩展）|
|扩展部分|根据扩展内容而定|</p>

<blockquote>
<p>SNI扩展</p>
</blockquote>

<ul>
<li>用于多域名识别，即一个端口同时支持多个证书</li>
<li>通过客户端明确提交目标域名，服务器根据该命名查找相应的证书（个人觉得也可以在证书内容做文章）</li>
</ul>

<pre>
<code>
def _server_name_ext(server_name):
    """
    服务器域名 -&gt; SNI 扩展
    :param server_name:
    """

    def __():
        yield '\x00'
        yield struct.pack('&gt;H', len(server_name))
        yield server_name

    s = ''.join(__())
    s = '%s%s' % (struct.pack('&gt;H', len(s)), s)
    return '%s%s' % (struct.pack('&gt;HH', 0x00, len(s)), s)
</code>
</pre>

<blockquote>
<p>证书类型扩展</p>
</blockquote>

<ul>
<li>由于是client-server模式，即很明确要求支持x509证书模式，openpgp不在目前的讨论范畴</li>
</ul>

<pre>
<code>
def _client_cert_type_ext(cert_type):
    """
    客户端证书类型扩展
    :param cert_type:
    :return:
    """
    if not isinstance(cert_type, int):
        raise ValueError('cert_type {0} invalid'.format(cert_type))

    def __():
        #length
        yield '\x01'
        yield struct.pack('&gt;B', cert_type)

    s = ''.join(__())
    #cert_type
    #length
    return '%s%s' % (struct.pack('&gt;HH', 0x09, len(s)), s)
</code>
</pre>

<p>h2. ServerHello</p>

<p>|字段|占用字节数|
|tls协议版本|2|
|服务器随机值|32（后文会详细说明）|
|session id长度|1（跟client保持一致）|
|session id|0|
|服务器加密套件id|2|
|压缩算法|1（不支持）|</p>

<p>h2. Server证书下发</p>

<ul>
<li>对于用于https的场景会有2个证书下发：域名自身证书+CA证书（用于证书链校验）</li>
<li>证书首先用于表明服务器的身份，其次用于协商出后续的对称密钥</li>
</ul>

<p>|字段|占用字节数|
|证书长度|3|
|证书内容|其他|</p>

<p>h2. ServerHelloDone</p>

<ul>
<li>该协议很简单，就只有tls协议头和空的协议字节，当然协议部分的长度说明有保留（明文封装导致）</li>
</ul>

<p>h2. ClientKeyExchange</p>

<ul>
<li>客户端生成48字节随机数，并根据服务器证书公钥加密得到256字节长预处理密钥，提交给服务器</li>
<li>服务器根据该密钥同客户端协商出最终的对称密钥</li>
</ul>

<pre>
<code>
def gen_exchange_client_key(der_cert_bytes):
    """
    生成用于交换的客户端key
    :param der_cert_bytes: der证书字节流
        pem格式的需要先转换到der
        上层调用须明确指定唯一证书
        尤其对于https握手阶段，服务器会返回2份证书
    """
    cert = Certificate.load(der_cert_bytes)
    cert = cert.native
    pub_key_info = cert.get('tbs_certificate').get('subject_public_key_info').get('public_key')

    #48字节随机数
    #bit0&amp;1设置为tls版本
    #rsa公钥加密，生成256bit
    random_48 = [ord(x) for x in urandom(48)]
    random_48[0] = 0x03
    random_48[1] = 0x03
    random_48 = ''.join((chr(x) for x in random_48))

    #加载公钥
    cipher = PKCS1_v1_5.new(RSA.construct((
        pub_key_info.get('modulus'),
        long(pub_key_info.get('public_exponent'))
    )))

    return random_48, cipher.encrypt(random_48)
</code>
</pre>

<p>|字段|占用字节|
|预处理密钥长度|2|
|预处理主密钥|256|</p>

<pre>
<code>
@TLSRecordWrap(22)
def client_key_ex(hs_track_hash, pre_master_secret):
    """
    交换密钥，该密钥通过rsa公钥加密

    :param hs_track_hash: 跟踪hash
    :param pre_master_secret: 随机生成的密钥，一般为256字节
    时序如下：
    * 解析服务器证书，获取公钥
    * 生成48字节随机数
    * 随机数头2字节设置为tls版本(3,3)
    * 公钥加密 -&gt; 256字节
    :param pre_master_secret:
    """
    s = [struct.pack('&gt;B', CLIENT_KEY_EXCHANGE_PROTOCOL)]

    tot = len(pre_master_secret)
    s.append(encode_bits(tot + 2, 3))
    s.append(struct.pack('&gt;H', tot))
    s.append(pre_master_secret)

    s = ''.join(s)
    gen_log.debug('track: %r' % s)
    hs_track_hash.update(s)
    yield s
</code>
</pre>

<p>h2. ClientChangeCipherSpec</p>

<ul>
<li>和服务器端一样，该协议仅1字节；1.3版本中已废弃该协议</li>
</ul>

<p>h2. ClientEncryptHandshakeMessage</p>

<ul>
<li>tls时序最重要的环节，client和server如何确定对方 <em>正确地</em> 实现了参数计算（这一点通过最终的加密值&amp;校验值验证），从而协商出双方都认可的对称密钥</li>
<li>整体上来讲，该环节以上文提到的预处理密钥为基础，通过一系列的哈希与加密计算得到了最终的结果；并且很重要的一点是计算过程综合了上文所有时序节点的中间参数，目的很明显，确保通讯过程不被篡改</li>
</ul>

<p>|参数|如何得到|
|client随机数|ClientHello时生成|
|serve随机数|ServerHello时下发|
|预处理密钥|根据server公钥和client48字节随机数产生|
|主密钥|根据 <em>预处理密钥</em> 生成|
|验证数据|根据 <em>主密钥</em> 和上述所有节点的 <em>track hash</em> 生成|
|校验hash|上文所有参数经算法处理得到的hash|</p>

<p>h3. 预处理密钥</p>

<ul>
<li>参考 [[Lib_tls_internals#ClientKeyExchange]]</li>
</ul>

<p>h3. 主密钥</p>

<p>说到主密钥的生成过程，必须提到tls计算中使用最频繁的一个函数：prf_12，用于密钥扩展，其原理是对输入参数不断做sha256哈希计算，直到达到一定长度为止</p>

<pre>
<code>
def prf_12(secret, seed, top):
    """
    针对tls1.2版本计算交换hash
    :param secret:
    :param seed:
    :param top:
    :return:
    """
    a = seed
    resp = ''

    while 1:
        a = HMAC.new(secret, a, SHA256).digest()
        output = HMAC.new(secret, a + seed, SHA256).digest()

        if len(resp) &gt;= top:
            return resp[:top]
        resp += output
</code>
</pre>

<p>以下便是主密钥（master_secret）的生成过程</p>

<pre>
<code>
master_secret = prf_12(
    self.__client_hello_env.get('ex_key').get('pre_m_key'),
    'master secret' + client_random + server_random,
    48
)
</code>
</pre>

<p>上文有提到最后一个环节client-server之间需要依赖某些参数判定对方真实有效，一切尽在由client发出的最后一个握手报文，组成如下：</p>

<pre>
<code>
AES.new(client_key, AES.MODE_CBC, client_iv).encrypt(pad(plain, 16))
</code>
</pre>

<p>那么这个函数调用至少有如下几个参数需要确定：</p>

<h1>
<a id="aes加密算法" class="anchor" href="#aes%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AES加密算法</h1>

<h1>
<a id="aes用到的key和iv" class="anchor" href="#aes%E7%94%A8%E5%88%B0%E7%9A%84key%E5%92%8Civ" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AES用到的key和iv</h1>

<h1>
<a id="明文" class="anchor" href="#%E6%98%8E%E6%96%87" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>明文</h1>

<blockquote>
<p>加密算法、key和iv如何协商</p>
</blockquote>

<h1>
<a id="根据服务器返回的加密套件cipher_suite映射得到加密算法和hash块长度" class="anchor" href="#%E6%A0%B9%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8A%A0%E5%AF%86%E5%A5%97%E4%BB%B6cipher_suite%E6%98%A0%E5%B0%84%E5%BE%97%E5%88%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%92%8Chash%E5%9D%97%E9%95%BF%E5%BA%A6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>根据服务器返回的加密套件（cipher_suite）映射得到加密算法和hash块长度</h1>

<h1>
<a id="根据主密钥扩展算法得到用于分割的整体块key_block" class="anchor" href="#%E6%A0%B9%E6%8D%AE%E4%B8%BB%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95%E5%BE%97%E5%88%B0%E7%94%A8%E4%BA%8E%E5%88%86%E5%89%B2%E7%9A%84%E6%95%B4%E4%BD%93%E5%9D%97key_block" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>根据主密钥扩展算法得到用于分割的整体块（key_block）</h1>

<h1>
<a id="根据各个block长度切割得到key和iv等参数" class="anchor" href="#%E6%A0%B9%E6%8D%AE%E5%90%84%E4%B8%AAblock%E9%95%BF%E5%BA%A6%E5%88%87%E5%89%B2%E5%BE%97%E5%88%B0key%E5%92%8Civ%E7%AD%89%E5%8F%82%E6%95%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>根据各个block长度切割得到key和iv等参数</h1>

<pre>
<code>
key_block = prf_12(
    master_secret,
    'key expansion' + server_random + client_random,
    (mac_len + cipher_obj.key_len + cipher_obj.iv_len) * 2
)
</code>
</pre>

<blockquote>
<p>明文如何得到</p>
</blockquote>

<ul>
<li>明文整体格式：</li>
</ul>

<p>|fix_iv|protocol_plain|mac_buf|pad_bytes|</p>

<ul>
<li>需要注意，上面有提到根据block长度切割得到各参数，参数切割过程分别针对client和server各有对应的block，意味着虽然是“对称加密”，client和server实际使用了不同的密钥</li>
<li>那么服务器只需要对密文做解密，核对校验数据（verify_data）是否一致即可，具体步骤如下：
## 根据主密钥计算得到校验数据（verify_data)
## 根据校验数据得到明文的协议包（最终服务器得到的是密文格式）
## 对明文计算hash
## 对aes这种块加密算法添加随机前缀（fix_iv），对于rc4这类流加密算法就不需要了
## 对上述的明文做补长（因为aes对此有要求）</li>
</ul>

<p>h1. 参考</p>

<h1>
<a id="tls协议分析与现代加密通信协议设计-httpsbloghelonginfoblog20150906tls-protocol-analysis-and-crypto-protocol-design" class="anchor" href="#tls%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%E7%8E%B0%E4%BB%A3%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1-httpsbloghelonginfoblog20150906tls-protocol-analysis-and-crypto-protocol-design" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>tls协议分析与现代加密通信协议设计 <a href="https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/</a>
</h1>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
