{
  "name": "这辈子跟技术耗上了 - Github.io",
  "tagline": "",
  "body": "{{>toc}}\r\n\r\nh1. tls报文概述\r\n\r\n* tls在tcp基础上构建，所以本质还是tcp；目的是在tcp基础上构建一个通信双方可信赖的安全通道，所以还是基于连接的会话\r\n* 这个会话经历 *握手* 和 *app层数据* 2个阶段；握手完成后即可传输application的应用数据\r\n* 整体结构由2部分组成：tls头部、具体协议；tls头部表明目前处于的状态（特指tls1.2及以上封装格式）\r\n* tls头部的结构固定由以下几字节组成，均以大端表示；在tls头部之后即紧跟着具体的协议字节\r\n\r\n|1|2|3|4|5|\r\n|ContentType|\\2=.TLS协议版本|\\2=.协议payload长度|\r\n\r\n* 协议版本&协议payload长度容易理解；ContentType表明tls协议栈当前所处的状态（tls时序规定必须先完成HandShake握手阶段，然后才能开始应用层传输数据，即ApplicationData状态，在这个过程中如果出现错误，都有可能出现Alert警告消息）\r\n## HandShake\r\n## Alert\r\n## ApplicationData\r\n## ChangeCipherSpec （tls1.3中已废除）\r\n\r\nh1. 时序\r\n\r\ntls协议基于证书链这种可以被通信双方信任的机制进行\r\n通信过程中以 *握手* 完成证书交换以及后续对称密钥的协商；握手之后即可通过对称密钥完成后续的业务数据交换\r\n\r\n!tls12_cd.png!\r\n\r\nh1. 封装算法\r\n\r\n表示 *握手* 和其他时序中协议报文的封装格式和注意点\r\n\r\nh2. ClientHello\r\n\r\nh3. 整体格式\r\n\r\n|1|2|3|4|more|\r\n|协议类型|\\3=.协议包长度（比较奇葩，tls头部仅用2字节表示长度，这里反而用3字节）|handshake握手数据段|\r\n\r\nh3. handshake数据段\r\n\r\n|说明|占用字节数|\r\n|tls版本|2|\r\n|client随机数|32|\r\n|协议会话id|1（不支持会话重建，用0表示即可）|\r\n|加密套件长度|套件count*2|\r\n|每个加密套件id|2|\r\n|是否支持压缩|1|\r\n|压缩算法|1（不支持压缩，置0即可）|\r\n|扩展长度|2（二进制表示，最长支持0xffff种扩展）|\r\n|扩展部分|根据扩展内容而定|\r\n\r\n> SNI扩展\r\n\r\n* 用于多域名识别，即一个端口同时支持多个证书\r\n* 通过客户端明确提交目标域名，服务器根据该命名查找相应的证书（个人觉得也可以在证书内容做文章）\r\n\r\n<pre>\r\n<code class=\"python\">\r\ndef _server_name_ext(server_name):\r\n    \"\"\"\r\n    服务器域名 -> SNI 扩展\r\n    :param server_name:\r\n    \"\"\"\r\n\r\n    def __():\r\n        yield '\\x00'\r\n        yield struct.pack('>H', len(server_name))\r\n        yield server_name\r\n\r\n    s = ''.join(__())\r\n    s = '%s%s' % (struct.pack('>H', len(s)), s)\r\n    return '%s%s' % (struct.pack('>HH', 0x00, len(s)), s)\r\n</code>\r\n</pre>\r\n\r\n> 证书类型扩展\r\n\r\n* 由于是client-server模式，即很明确要求支持x509证书模式，openpgp不在目前的讨论范畴\r\n\r\n<pre>\r\n<code class=\"python\">\r\ndef _client_cert_type_ext(cert_type):\r\n    \"\"\"\r\n    客户端证书类型扩展\r\n    :param cert_type:\r\n    :return:\r\n    \"\"\"\r\n    if not isinstance(cert_type, int):\r\n        raise ValueError('cert_type {0} invalid'.format(cert_type))\r\n\r\n    def __():\r\n        #length\r\n        yield '\\x01'\r\n        yield struct.pack('>B', cert_type)\r\n\r\n    s = ''.join(__())\r\n    #cert_type\r\n    #length\r\n    return '%s%s' % (struct.pack('>HH', 0x09, len(s)), s)\r\n</code>\r\n</pre>\r\n\r\nh2. ServerHello\r\n\r\n|字段|占用字节数|\r\n|tls协议版本|2|\r\n|服务器随机值|32（后文会详细说明）|\r\n|session id长度|1（跟client保持一致）|\r\n|session id|0|\r\n|服务器加密套件id|2|\r\n|压缩算法|1（不支持）|\r\n\r\nh2. Server证书下发\r\n\r\n* 对于用于https的场景会有2个证书下发：域名自身证书+CA证书（用于证书链校验）\r\n* 证书首先用于表明服务器的身份，其次用于协商出后续的对称密钥\r\n\r\n|字段|占用字节数|\r\n|证书长度|3|\r\n|证书内容|其他|\r\n\r\nh2. ServerHelloDone\r\n\r\n* 该协议很简单，就只有tls协议头和空的协议字节，当然协议部分的长度说明有保留（明文封装导致）\r\n\r\nh2. ClientKeyExchange\r\n\r\n* 客户端生成48字节随机数，并根据服务器证书公钥加密得到256字节长预处理密钥，提交给服务器\r\n* 服务器根据该密钥同客户端协商出最终的对称密钥\r\n\r\n<pre>\r\n<code class=\"python\">\r\ndef gen_exchange_client_key(der_cert_bytes):\r\n    \"\"\"\r\n    生成用于交换的客户端key\r\n    :param der_cert_bytes: der证书字节流\r\n        pem格式的需要先转换到der\r\n        上层调用须明确指定唯一证书\r\n        尤其对于https握手阶段，服务器会返回2份证书\r\n    \"\"\"\r\n    cert = Certificate.load(der_cert_bytes)\r\n    cert = cert.native\r\n    pub_key_info = cert.get('tbs_certificate').get('subject_public_key_info').get('public_key')\r\n\r\n    #48字节随机数\r\n    #bit0&1设置为tls版本\r\n    #rsa公钥加密，生成256bit\r\n    random_48 = [ord(x) for x in urandom(48)]\r\n    random_48[0] = 0x03\r\n    random_48[1] = 0x03\r\n    random_48 = ''.join((chr(x) for x in random_48))\r\n\r\n    #加载公钥\r\n    cipher = PKCS1_v1_5.new(RSA.construct((\r\n        pub_key_info.get('modulus'),\r\n        long(pub_key_info.get('public_exponent'))\r\n    )))\r\n\r\n    return random_48, cipher.encrypt(random_48)\r\n</code>\r\n</pre>\r\n\r\n|字段|占用字节|\r\n|预处理密钥长度|2|\r\n|预处理主密钥|256|\r\n\r\n<pre>\r\n<code class=\"python\">\r\n@TLSRecordWrap(22)\r\ndef client_key_ex(hs_track_hash, pre_master_secret):\r\n    \"\"\"\r\n    交换密钥，该密钥通过rsa公钥加密\r\n\r\n    :param hs_track_hash: 跟踪hash\r\n    :param pre_master_secret: 随机生成的密钥，一般为256字节\r\n    时序如下：\r\n    * 解析服务器证书，获取公钥\r\n    * 生成48字节随机数\r\n    * 随机数头2字节设置为tls版本(3,3)\r\n    * 公钥加密 -> 256字节\r\n    :param pre_master_secret:\r\n    \"\"\"\r\n    s = [struct.pack('>B', CLIENT_KEY_EXCHANGE_PROTOCOL)]\r\n\r\n    tot = len(pre_master_secret)\r\n    s.append(encode_bits(tot + 2, 3))\r\n    s.append(struct.pack('>H', tot))\r\n    s.append(pre_master_secret)\r\n\r\n    s = ''.join(s)\r\n    gen_log.debug('track: %r' % s)\r\n    hs_track_hash.update(s)\r\n    yield s\r\n</code>\r\n</pre>\r\n\r\nh2. ClientChangeCipherSpec\r\n\r\n* 和服务器端一样，该协议仅1字节；1.3版本中已废弃该协议\r\n\r\nh2. ClientEncryptHandshakeMessage\r\n\r\n* tls时序最重要的环节，client和server如何确定对方 *正确地* 实现了参数计算（这一点通过最终的加密值&校验值验证），从而协商出双方都认可的对称密钥\r\n* 整体上来讲，该环节以上文提到的预处理密钥为基础，通过一系列的哈希与加密计算得到了最终的结果；并且很重要的一点是计算过程综合了上文所有时序节点的中间参数，目的很明显，确保通讯过程不被篡改\r\n\r\n|参数|如何得到|\r\n|client随机数|ClientHello时生成|\r\n|serve随机数|ServerHello时下发|\r\n|预处理密钥|根据server公钥和client48字节随机数产生|\r\n|主密钥|根据 *预处理密钥* 生成|\r\n|验证数据|根据 *主密钥* 和上述所有节点的 *track hash* 生成|\r\n|校验hash|上文所有参数经算法处理得到的hash|\r\n\r\nh3. 预处理密钥\r\n\r\n* 参考 [[Lib_tls_internals#ClientKeyExchange]]\r\n\r\nh3. 主密钥\r\n\r\n说到主密钥的生成过程，必须提到tls计算中使用最频繁的一个函数：prf_12，用于密钥扩展，其原理是对输入参数不断做sha256哈希计算，直到达到一定长度为止\r\n\r\n<pre>\r\n<code class=\"python\">\r\ndef prf_12(secret, seed, top):\r\n    \"\"\"\r\n    针对tls1.2版本计算交换hash\r\n    :param secret:\r\n    :param seed:\r\n    :param top:\r\n    :return:\r\n    \"\"\"\r\n    a = seed\r\n    resp = ''\r\n\r\n    while 1:\r\n        a = HMAC.new(secret, a, SHA256).digest()\r\n        output = HMAC.new(secret, a + seed, SHA256).digest()\r\n\r\n        if len(resp) >= top:\r\n            return resp[:top]\r\n        resp += output\r\n</code>\r\n</pre>\r\n\r\n以下便是主密钥（master_secret）的生成过程\r\n\r\n<pre>\r\n<code class=\"python\">\r\nmaster_secret = prf_12(\r\n    self.__client_hello_env.get('ex_key').get('pre_m_key'),\r\n    'master secret' + client_random + server_random,\r\n    48\r\n)\r\n</code>\r\n</pre>\r\n\r\n上文有提到最后一个环节client-server之间需要依赖某些参数判定对方真实有效，一切尽在由client发出的最后一个握手报文，组成如下：\r\n\r\n<pre>\r\n<code class=\"python\">\r\nAES.new(client_key, AES.MODE_CBC, client_iv).encrypt(pad(plain, 16))\r\n</code>\r\n</pre>\r\n\r\n那么这个函数调用至少有如下几个参数需要确定：\r\n\r\n# AES加密算法\r\n# AES用到的key和iv\r\n# 明文\r\n\r\n> 加密算法、key和iv如何协商\r\n\r\n# 根据服务器返回的加密套件（cipher_suite）映射得到加密算法和hash块长度\r\n# 根据主密钥扩展算法得到用于分割的整体块（key_block）\r\n# 根据各个block长度切割得到key和iv等参数\r\n\r\n<pre>\r\n<code class=\"python\">\r\nkey_block = prf_12(\r\n    master_secret,\r\n    'key expansion' + server_random + client_random,\r\n    (mac_len + cipher_obj.key_len + cipher_obj.iv_len) * 2\r\n)\r\n</code>\r\n</pre>\r\n\r\n> 明文如何得到\r\n\r\n* 明文整体格式：\r\n\r\n|fix_iv|protocol_plain|mac_buf|pad_bytes|\r\n\r\n* 需要注意，上面有提到根据block长度切割得到各参数，参数切割过程分别针对client和server各有对应的block，意味着虽然是“对称加密”，client和server实际使用了不同的密钥\r\n* 那么服务器只需要对密文做解密，核对校验数据（verify_data）是否一致即可，具体步骤如下：\r\n## 根据主密钥计算得到校验数据（verify_data)\r\n## 根据校验数据得到明文的协议包（最终服务器得到的是密文格式）\r\n## 对明文计算hash\r\n## 对aes这种块加密算法添加随机前缀（fix_iv），对于rc4这类流加密算法就不需要了\r\n## 对上述的明文做补长（因为aes对此有要求）\r\n\r\nh1. 参考\r\n\r\n# tls协议分析与现代加密通信协议设计 https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}